#include "sfilter.h"

#include <assert.h>
#include <stdio.h>

#include "cipher.h"
#include "pconn.h"
#include "sslog.h"
#include "stream_buf.h"

#define PACKET_HEAD_LEN 4
#define MAX_PAYLOAD_LEN (1024 * 1)

#ifndef _ALLOC
#define _ALLOC(_p, _type, _size)   \
    (_p) = (_type)malloc((_size)); \
    if (!(_p)) {                   \
        perror("alloc error");     \
        exit(1);                   \
    }
#endif

int sfilter_in(stream_buf_t* sb, const char* in, int in_len, char** out, int* out_len) {
    if (!sb || in_len <= 0 || !in || !out || !out_len) return _ERR;

    sb_write(sb, in, in_len);
    int rlen = sb_get_size(sb);
    if (rlen <= PACKET_HEAD_LEN) return _OK;

    char* _ALLOC(rbuf, char*, rlen);
    memset(rbuf, 0, rlen);
    int rt = sb_read_all(sb, rbuf, rlen);
    assert(rt == rlen);

    uint32_t payload_len;
    memcpy(&payload_len, rbuf, 4);
    payload_len = ntohl(payload_len);
    if (payload_len > MAX_PAYLOAD_LEN) {
        _LOG_E("recv payload_len:%d error", payload_len);
        free(rbuf);
        return _ERR;
    }

    int total_packet_len = PACKET_HEAD_LEN + payload_len;
    if (rlen < total_packet_len) {
        sb_write(sb, rbuf, rlen);
        free(rbuf);
        return _NEED_MORE;
    }

    _ALLOC(*out, char*, payload_len);
    memcpy(*out, rbuf + PACKET_HEAD_LEN, payload_len);
    *out_len = payload_len;

    /* TODO: */
    *out = (char*)in;
    *out_len = in_len;
    return _OK;
}

int sfilter_out(int fd, const char* in, int in_len, char** out, int* out_len) {
    if (fd < 0 || in_len <= 0 || !in || !out || !out_len) {
        return _ERR;
    }
    /* get connection */
    /* check connection */
    /* get connection info */
    /* unpack_decrypt or encrypt_pack */
    *out = (char*)in;
    *out_len = in_len;
    return _OK;
}